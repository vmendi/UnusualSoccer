<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009"
			   xmlns:s="library://ns.adobe.com/flex/spark"
			   xmlns:local="*"
			   width="760" height="650" applicationComplete="ApplicationCompleteHandler(event)"
			   frameRate="30" preloader="ProgressPreloader">
	
	<fx:Metadata>
		[ResourceBundle("main")]
		[ResourceBundle("training")]
		[ResourceBundle("teams")]
		[ResourceBundle("matchmsgs")]
	</fx:Metadata>
	
	<!-- Todas las fuentes se embeben aquí -->
	<fx:Style>
		@namespace s "library://ns.adobe.com/flex/spark";
		
		@font-face {
			src:url("/Assets/Fonts/HelveticaNeueLT/lte50874.ttf");
			fontFamily: MyFontHelveticaNeueLTBold;
			font-weight: bold;
			embedAsCFF: true;
		}
	</fx:Style>
	

	<fx:Script><![CDATA[
		import GameModel.MainGameModel;
		
		import GameView.MainView;
		
		import HttpService.DataTypeInitializer;
		
		import Match.MatchMain;
		
		import mx.events.FlexEvent;
		
		import utils.UIComponentWrapper;

		protected function ApplicationCompleteHandler(event:FlexEvent):void
		{
			// While we initialize FB, etc we also need to show the "Wait" screen (after the preloader)
			createLoadingScreen();
			
			GameMetrics.ReportEvent(GameMetrics.SWF_LOADED, null);
			
			// FPSCounter.Init(this.stage, new Point(0,0));
						
			Security.allowDomain("*");	// CDN
						
			// Excepciones globales capturadas
			if (loaderInfo.hasOwnProperty("uncaughtErrorEvents"))
				IEventDispatcher(loaderInfo["uncaughtErrorEvents"]).addEventListener("uncaughtError", ErrorMessages.UncaughtErrorHandler);
			
			// Si se dispara esta señal, la dispare quien la dispare, nos quedamos en blanco
			ErrorMessages.OnCleaningShutdownSignal.addOnce(OnCleaningShutdown);
			
			// Carga de parametros y configuracion global
			AppConfig.Init(parameters);
			
			// Para que las estructuras creadas por weborb existan
			var dataTypeInit : DataTypeInitializer = new DataTypeInitializer();

			if (AppConfig.TEST != null)
			{
				mFacebookFacade = new FacebookFacade();
				mMainGameModel = new MainGameModel();
				
				MyServerTests.visible = true;
				MyServerTests.ExecuteTest(AppConfig.TEST);
			}
			else
			{
				mFacebookFacade = new FacebookFacade();
				mFacebookFacade.Init(OnFacebookInitSuccess);
			}
		}
		
		private function OnFacebookInitSuccess():void
		{
			ConfigureLocale();

			// Podemos ir cargando recursos que luego necesitaremos (despues de tener el Locale configurado)
			MatchMain.LoadMatchResources(null);
			
			mMainGameModel = new MainGameModel();
			mMainGameModel.InitialRefresh(OnInitialRefreshSuccess);

			function OnInitialRefreshSuccess() : void
			{
				mMainView = new MainView();
				mMainView.addEventListener(Event.ADDED_TO_STAGE, function() : void
				{
					// Hide our loading screen
					removeElement(mLoadingScreen);
				});
				addElement(mMainView);
			}
		}
		
		private function ConfigureLocale() : void
		{
			// El servidor siempre nos pasa un locale coherente con el VERSION_ID, aqui no tenemos que hacer nada
			resourceManager.localeChain = GetLocaleChain(AppConfig.LOCALE);

			function GetLocaleChain(locale : String) : Array
			{
				// El idioma que soportamos es el [0], los fallback que aplicara Flex cuando no 
				// encuentra un recurso en ese idioma estan a continuacion
				var chains : Array = [ 
										["en_US", "es_ES"],
										["es_ES", "en_US"],				// Español MahouLigachapas
										["es_LA", "es_ES", "en_US"],	// Español mundo
									];
				
				var ret : Array = null;
				
				for each(var chain : Array in chains)
				{
					if (chain[0] == locale)
					{
						ret = chain;
						break;
					}
				}
				
				// Por completitud: Si no es uno de los soportados, devolvemos nuestra cadena ingles-español favorita,
				// pero esto no deberia pasar jamas.
				if (ret == null)
				{
					ErrorMessages.LogToServer("WARNING: Unrecognized locale from server " + locale);
					ret = ["en_US", "es_ES"];
				}
				
				return ret;
			}
		}
		
		private function OnCleaningShutdown() : void
		{
			if (mMainGameModel != null)
			{
				mMainGameModel.OnCleaningShutdown();
				
				// Antes lo poniamos a null pero hemos comprobado que cuando llega un OnCleaningShutdown es posible que aun llegue alguna 
				// respuesta desde el servidor. Por ejemplo, la respuesta del cambio de formación, provoca un updateDisplayList dentro del
				// FormationLayout que a su vez llama a GetPointsForFielPos que asume que SoccerClient.GetMainGameModel() != null. Se asume
				// además en un monton de sitios.
				// mMainGameModel = null;
			}
			
			// Quitamos la mMainView pero tb todos los posibles popups q hubiera
			removeAllElements();
			mMainView = null;
		}
		
		private function createLoadingScreen():void
		{    			
			var loadingIcon : mcLoading = new mcLoading();
			
			if (AppConfig.IsMahouLigaChapas)
				loadingIcon.gotoAndStop(1);
			else
				loadingIcon.gotoAndStop(2);
										
			loadingIcon.x = 0;
			loadingIcon.y = 0;
			
			mLoadingScreen = new UIComponentWrapper(loadingIcon); 
			
			addElement(mLoadingScreen);
		}		
		
		private var mMainView : MainView;
		
		// Here we also want a "Wait" (in addition to the preloader). Currently, it's a screen that covers the whole area
		private var mLoadingScreen : UIComponentWrapper;
		
		/// En vez de andar pasándolo por ahí en Inits, singletonizamos
		static private var mMainGameModel : MainGameModel;
		static public function GetMainGameModel() : MainGameModel {	return mMainGameModel; }
		
		// Idem
		static private var mFacebookFacade : FacebookFacade;
		static public function GetFacebookFacade() : FacebookFacade { return mFacebookFacade; }
	
	]]></fx:Script>
	
	<s:BitmapImage source="{resourceManager.getClass('main','LoginBg')}" fillMode="clip" top="0"/>
	
	<local:ServerTests id="MyServerTests" visible="false" width="100%" height="100%"/>
			
</s:Application>
