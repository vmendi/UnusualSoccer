<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" width="50" height="50">
		
	<fx:Script><![CDATA[
		import spark.primitives.BitmapImage;
		
		[Bindable]
		public function set FacebookID(id : String) : void
		{
			mFacebookID = id;
			
			LoadPicture(mFacebookID);
		}		
		public function get FacebookID() : String
		{
			return mFacebookID;
		}
				
		// square, small, large
		[Bindable]
		public function get Size() : String { return mSize; }
		public function set Size(v:String) : void { mSize = v; }
			
		
		private function LoadPicture(userID : String) : void
		{
			removeAllElements();
			
			if (mImagesCache.hasOwnProperty(userID + Size))
			{				
				mImage = mImagesCache[userID+Size];
				
				// Usamos la condicion de no estar en la stage para determinar que es reusable. Es decir, si la imagen que esta
				// en el cache esta siendo pintada, clonamos, provocando recarga desde la red.
				// A veces no usa el cache cuando podría hacerlo por culpa del virtual layout, que no llega a remover elementos 
				// de la stage, los deja "ahí" (no visibles) para reusarlos.
				// Lo ideal sería poder hacer un clon rapido sin pasar por el mImage.source, que fuerza una recarga desde la red
				// puesto que el source es un URLRequest. El problema es que el clon rapido implica el clonado del BitmapData, y
				// el modelo de seguridad no lo permite a no ser que cargues un crossdomain.xml. Entonces, estas imagenes estan
				// cargadas mediante redireccion a CDN, y solo se carga el crossdomain.xml del principal. Cargar los posibles xmls
				// dependiendo del CDN que toque parece un movidon/error.
				// Un tio al que le paso lo mismo:
				// http://jessewarden.com/2009/03/handling-crossdomainxml-and-302-redirects-using-netstream.html
				if (mImage.parent != null && mImage.parent.stage != null)
				{
					var cachedSource : Object = mImage.source;
					
					mImage = new BitmapImage();
					mImage.source = cachedSource;
				}				
			}
			else
			{
				mImage = new BitmapImage();
				mImagesCache[userID+Size] = mImage;

				// El cache spark (ContentCache) no funciona por culpa de la redireccion que hace FB
				mImage.source = new URLRequest("http://graph.facebook.com/"+userID+"/picture/?type="+mSize);
			}
			
			addElement(mImage);
		}

		private var mImage : BitmapImage;
		private var mFacebookID : String;
		private var mSize : String = "square";		
		
		// Este es el unico objeto que usamos para cargar imagenes de facebook, asi que este es el unico Cache
		static private var mImagesCache : Object = new Object();
	]]></fx:Script>
			
</s:Group>
