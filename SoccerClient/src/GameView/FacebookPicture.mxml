<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" width="50" height="50">
		
	<fx:Script><![CDATA[
		import com.greensock.TweenNano;
		
		import mx.messaging.messages.ErrorMessage;
		
		import spark.components.Image;
		import spark.primitives.BitmapImage;
		
		[Bindable]
		public function set FacebookID(id : String) : void
		{
			mFacebookID = id;
			
			LoadPicture(mFacebookID);
		}		
		public function get FacebookID() : String
		{
			return mFacebookID;
		}
				
		// square, small, large
		[Bindable]
		public function get Size() : String { return mSize; }
		public function set Size(v:String) : void { mSize = v; }
			
		
		private function LoadPicture(userID : String) : void
		{
			removeAllElements();
			
			// Contamos con que FacebookID == -1 en caso de que una chapa no tenga amigo asignado
			if (userID.indexOf("-") != -1)
				return;
			
			if (mImagesCache.hasOwnProperty(userID + Size))
			{
				mImage = new BitmapImage();
				mImage.source = (mImagesCache[userID+Size] as BitmapImage).source;
				
				addElement(mImage);
			}
			else
			{
				load();
				
				// OLD OLD OLD
				// Lo ideal sería poder hacer un clon rapido sin pasar por el mImage.source, que fuerza una recarga desde la red
				// puesto que el source es un URLRequest. El problema es que el clon rapido implica el clonado del BitmapData, y
				// el modelo de seguridad no lo permite a no ser que cargues un crossdomain.xml. Entonces, estas imagenes estan
				// cargadas mediante redireccion a CDN, y solo se carga el crossdomain.xml del principal. Cargar los posibles xmls
				// dependiendo del CDN que toque parece un movidon/error.
				// Un tio al que le paso lo mismo:
				// http://jessewarden.com/2009/03/handling-crossdomainxml-and-302-redirects-using-netstream.html
				// OLD END
				//
				// NEW: Finalmente hemos implementado el movidon. Atencion al timer!
				//
				function load() : void
				{					
					mLoader = new Loader();
					mLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, onComplete);
					mLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onError);
					mLoader.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onError);
					mLoader.load(new URLRequest("http://graph.facebook.com/"+userID+"/picture/?type="+mSize));
				}
				
				function onError(e:Event):void
				{
					// Poco podemos hacer...
				}
				
				function onComplete(e:Event):void
				{
				 	var loaderInfo : LoaderInfo = e.target as LoaderInfo;
					
					// Por el useVirtualLayout de las listas, nos reusaran... entonces, llegara el onComplete de un loader ya obsoleto
					if (loaderInfo.bytesTotal != 0 && loaderInfo.bytesLoaded == loaderInfo.bytesTotal && 
						mLoader != null && loaderInfo == mLoader.contentLoaderInfo)
					{
						// Esto nos indica cuándo se ha cargado con redireccion
						if (!mLoader.contentLoaderInfo.childAllowsParent)
						{
							if (mLoader.contentLoaderInfo.isURLInaccessible)
							{
								// oh my goodness...
								Security.loadPolicyFile(mLoader.contentLoaderInfo.url + "crossdomain.xml");
							
								// Suponemos que 3 segundos es suficiente para que le de tiempo a cargar la policy.
								// No, lamentablemente no hay forma de preguntarle de ninguna otra manera. En los docs sugieren hacer polling
								// del childAllowsParent...
								TweenNano.delayedCall(3, load);
							}
							else
							{
								// Este caso no nos lo hemos encontrado, parece que el CDN de FB esta configurado siempre para que NO nos devuelva la URL completa
								// de las fotos. De momento lo dejamos sin implementar a ver si ocurre alguna vez
								ErrorMessages.LogToServer("Error horrible, la URL deberia ser inaccesible");
								throw new Error("DEBUG DEBUG DEBUG");
							}
						}
						else
						{
							mImage = new BitmapImage();
							mImagesCache[userID+Size] = mImage;
							mImage.source = mLoader.content;	
							
							addElement(mImage);
						}
						
						mLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE, onComplete);
						mLoader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onError);
						mLoader.contentLoaderInfo.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onError);
						mLoader = null;
					}
				}
			}
		}
		
		private var mLoader : Loader;

		private var mImage : BitmapImage;
		private var mFacebookID : String;
		private var mSize : String = "square";		
		
		// Este es el unico objeto que usamos para cargar imagenes de facebook, asi que este es el unico Cache
		static private var mImagesCache : Object = new Object();
	]]></fx:Script>
			
</s:Group>
